================================================================================
         CNC 스마트팩토리 시스템 아키텍처 설명
         (시니어 엔지니어 대상 전체 설명 + 지적 사항)
================================================================================


================================================================================
1. 시스템 개요: 이 시스템이 무엇인가
================================================================================

1.1 목적
--------------------------------------------------------------------------------
FANUC CNC 자동선반(Bar Feeder 연동)을 웹 기반으로 모니터링하고
제한적 원격 제어를 수행하는 시스템입니다.

핵심 키워드는 "제한적 원격 제어"입니다.
직접 NC 조작(조그, MDI 입력 등)은 불가하고,
스케줄러를 통한 프로그램 순차 실행만 허용합니다. 이는 안전상의 이유입니다.


1.2 주요 기능 4가지
--------------------------------------------------------------------------------
1. 모니터링     - 장비 상태, 알람, 생산 현황 실시간 확인
2. 스케줄러     - 프로그램 대기열 기반 순차 자동 실행
3. Transfer     - 프로그램 입출력, 백업
4. POP/MES 연계 - 생산실적 집계, 작업지시 관리


1.3 사용자 권한 체계
--------------------------------------------------------------------------------
+---------------+-----------------------------------------------------+
| 일반 사용자   | 모니터링 전용 (읽기만)                              |
| 관리자(Admin) | 스케줄러 실행, 설정 변경, Transfer                  |
| AS 담당자     | 템플릿 관리, 전체 설정 접근                         |
+---------------+-----------------------------------------------------+

[지적 1: 권한 경계 모호]
- 관리자와 AS 담당자의 "설정" 권한이 겹침
- "전체 설정 접근"이 Machine Settings도 포함하는지 불명확
- 메뉴/버튼 레벨의 접근 제어 매트릭스 필요


================================================================================
2. 4-Tier 아키텍처
================================================================================

+---------------------------------------------------------------------+
|                    Frontend (Web UI)                                |
|               React + TypeScript + Vite + Zustand                   |
+---------------------------------------------------------------------+
                              |
                              | REST API / WebSocket
                              v
+---------------------------------------------------------------------+
|                   Central Server (Backend)                          |
|              Node.js + Express + TypeScript                         |
|              MQTT Client + WebSocket Server                         |
+---------------------------------------------------------------------+
                              |
                              | MQTT Protocol
                              v
+---------------------------------------------------------------------+
|                    Field Agent (Edge)                               |
|                    C# .NET 8 Worker Service                         |
|                    FOCAS2 P/Invoke (장비당 1개)                     |
+---------------------------------------------------------------------+
                              |
                              | FOCAS2 (Ethernet/HSSB)
                              v
+---------------------------------------------------------------------+
|                      CNC Controller                                 |
|                    FANUC (0i-TF, 30i 등)                            |
+---------------------------------------------------------------------+


2.1 각 계층의 책임
--------------------------------------------------------------------------------
| 계층     | 책임                                    | 비책임              |
|----------|----------------------------------------|---------------------|
| Frontend | UI, WebSocket 수신, REST 요청, 상태관리 | 비즈니스 로직       |
| Server   | REST API, WebSocket, MQTT, DB, 인증/인가| FOCAS 직접 통신     |
| Agent    | FOCAS 통신, 실시간 수집, 템플릿 추상화  | 비즈니스 로직 판단  |
| CNC      | 실제 가공 수행                          | -                   |


2.2 통신 프로토콜 선택 이유
--------------------------------------------------------------------------------
Frontend <-> Server : REST (명령) + WebSocket (실시간 푸시)
Server <-> Agent    : MQTT (pub/sub, 비동기, 다수 Agent 관리에 적합)
Agent <-> CNC       : FOCAS2 (FANUC 공식 라이브러리, 유일한 선택지)


[지적 2: 책임 경계 충돌 가능성]

문서에서 Server가 "인증/인가 처리"를 담당한다고 했는데,
Agent에서도 "인터록 조건 검증"을 수행합니다.

질문: 권한 없는 사용자가 MQTT를 직접 조작하면?
- Server를 우회해서 Agent에 직접 명령 전송 가능
- Agent 레벨에서도 인증 검증이 필요하거나, MQTT Broker ACL 설정 필수
- 현재 아키텍처에서는 이 부분이 누락됨


================================================================================
3. 설정 아키텍처: 3-Level 구조
================================================================================

+---------------------------------------------------------------------+
|              Global Settings (시스템 전역)                          |
|         POP 계산 공식, KPI 표시, 시스템 기본값                      |
+---------------------------------------------------------------------+
                              | 상속 (기본값 제공)
                              v
+---------------------------------------------------------------------+
|              Machine Settings (장비별)                              |
|      IP, 포트, 스케줄러 모드, 네트워크 폴더, 인터록 ON/OFF          |
+---------------------------------------------------------------------+
                              | 참조 (template_id)
                              v
+---------------------------------------------------------------------+
|              Template Settings (기종별)                             |
|           PMC 주소 매핑 (논리명 -> 실제 주소)                       |
+---------------------------------------------------------------------+


3.1 왜 이렇게 분리했는가
--------------------------------------------------------------------------------
문제: 동일 FANUC이라도 기종/옵션에 따라 PMC 주소가 다름

예: "도어 닫힘" 신호
- 0i-TF A사 장비: X12.5
- 0i-TF B사 장비: X15.2
- 30i-B 장비: G100.0

해결: Template이 "doorClosed" -> 실제 PMC 주소 매핑을 담당
- 동일 기종 장비는 같은 Template 공유
- Machine은 Template을 참조만 함


3.2 설정 상속 규칙
--------------------------------------------------------------------------------
Global: schedulerMode = 'auto'
                |
Machine A: schedulerMode = 'manual'  -> 'manual' 적용 (재정의)
Machine B: schedulerMode = (미설정)  -> 'auto' 적용 (상속)


[지적 3: 인터록 비활성화 안전 문제]

Machine Settings에서 개별 인터록 조건을 ON/OFF 할 수 있습니다:

interlock: {
  conditions: {
    doorClosed: boolean;      // 도어 체크 활성화
    spindleStopped: boolean;  // 스핀들 정지 체크 활성화
  }
}

위험: 관리자가 doorClosed: false로 설정하면
      도어 열린 상태에서 사이클 시작 가능

필요한 조치:
1. 필수 인터록(비활성화 불가)과 선택 인터록 분리
2. 비활성화 시 AS 담당자 승인 필요
3. 비활성화 사유 및 기간 기록 (감사 로그)


================================================================================
4. 템플릿 시스템 상세
================================================================================

4.1 템플릿 구조
--------------------------------------------------------------------------------
interface EquipmentTemplate {
  templateId: string;        // "FANUC_0iTF_v2"
  version: string;           // SemVer

  pmcMap: {
    interlock: {
      doorClosed: PMCAddress;      // { type: 'X', address: 12, bit: 5 }
      chuckClamped: PMCAddress;
      spindleStopped: PMCAddress;
      barFeederReady: PMCAddress;
    };
    status: {
      operationMode: PMCAddress;
      cycleRunning: PMCAddress;
      programEnd: PMCAddress;      // M30 신호
    };
    control: {
      cycleStart: PMCAddress;      // 사이클 스타트 출력
      feedHold: PMCAddress;
    };
    counters: {
      partCount: PMCAddress;
    };
  };

  capabilities: {
    hasBarFeeder: boolean;
    hasSubSpindle: boolean;
  };
}


4.2 템플릿 적용 흐름
--------------------------------------------------------------------------------
1. AS 담당자가 기종별 PMC 주소 조사 -> 템플릿 생성
2. 관리자가 Machine에 templateId 할당
3. Agent 시작 시 Server에서 템플릿 다운로드
4. Agent가 "doorClosed" 요청 -> 템플릿에서 X12.5 획득 -> FOCAS 호출
5. 데이터 추상화: { "doorClosed": true } (PMC 주소 노출 없음)


[지적 4: 템플릿 로드 시점 문제]

"Agent 시작 시 Server에서 템플릿 정보 수신"

문제 시나리오:
1. Server 다운 상태에서 Agent 재시작
2. 템플릿을 받을 수 없음
3. Agent 동작 불가

문서 9.2.3에서는 "Server 다운 -> Agent 독립 동작 (로컬 캐싱)"이라고 했는데,
이 두 내용이 모순입니다.

필요한 정의:
- 템플릿 로컬 캐싱 여부
- 캐시 유효 기간
- 템플릿 버전 변경 시 동기화 방법


================================================================================
5. 데이터 흐름
================================================================================

5.1 실시간 모니터링 (CNC -> Frontend)
--------------------------------------------------------------------------------

CNC Controller
      |
      | FOCAS2 API (100~500ms 주기)
      v
+---------------------------------------------------------------------+
| Agent                                                               |
| 1. cnc_rdactpt (좌표)                                               |
| 2. cnc_statinfo (상태)                                              |
| 3. cnc_rdpmcrng (PMC 신호)                                          |
| 4. 템플릿 기반 추상화 -> JSON 구성                                  |
+---------------------------------------------------------------------+
      |
      | MQTT Publish: machines/{machineId}/status
      v
+---------------------------------------------------------------------+
| Server                                                              |
| 1. MQTT Subscribe                                                   |
| 2. 데이터 캐싱                                                      |
| 3. 필요 시 DB 저장                                                  |
+---------------------------------------------------------------------+
      |
      | WebSocket Push
      v
+---------------------------------------------------------------------+
| Frontend                                                            |
| 1. WebSocket 수신                                                   |
| 2. Zustand Store 업데이트                                           |
| 3. React 리렌더링                                                   |
+---------------------------------------------------------------------+


5.2 명령 전송 (Frontend -> CNC)
--------------------------------------------------------------------------------

Frontend (관리자)
      |
      | POST /api/machines/{id}/command
      v
+---------------------------------------------------------------------+
| Server                                                              |
| 1. 인증 확인 (JWT/Session)                                          |
| 2. 권한 확인 (Admin 이상)                                           |
| 3. 명령 유효성 검증                                                 |
| 4. 명령 큐 등록                                                     |
+---------------------------------------------------------------------+
      |
      | MQTT Publish: machines/{machineId}/command
      v
+---------------------------------------------------------------------+
| Agent                                                               |
| 1. 인터록 조건 검증 (템플릿 PMC 확인)                               |
| 2. 조건 충족 시 FOCAS 함수 호출                                     |
| 3. 결과 응답                                                        |
+---------------------------------------------------------------------+
      |
      | FOCAS2 API
      v
CNC Controller


[지적 5: 명령 응답 흐름 누락]

명령 전송 흐름은 있는데, 응답이 Frontend까지 어떻게 전달되는지 정의가 없습니다.

- Agent -> Server: MQTT? 어떤 토픽?
- Server -> Frontend: REST 응답? WebSocket 푸시?
- 비동기 명령의 완료 알림 방법?


================================================================================
6. 스케줄러: 핵심 기능
================================================================================

6.1 스케줄러 개념
--------------------------------------------------------------------------------
Bar Feeder 연동 자동선반에서 프로그램을 순차적으로 자동 실행하는 기능입니다.

+---------------------------------------------------------------------+
|  Main PGM | Sub PGM | PRESET | COUNT    | Status | Delete          |
+-----------+---------+--------+----------+--------+-----------------+
|  O0001    | O0100   | 50     | 23/50    | 실행중 |   [X]           |
|  O0002    | O0101   | 30     | 0/30     | 대기   |   [X]           |
|  O0003    | -       | 200    | 0/200    | 대기   |   [X]           |
+---------------------------------------------------------------------+
          [시작]  [정지]  [리셋]

- PRESET: 목표 생산 수량
- COUNT: 현재/목표 (실시간 갱신)
- 위에서 아래로 순차 실행
- 한 항목 PRESET 도달 시 다음 항목으로 자동 전환


6.2 스케줄러 실행 흐름
--------------------------------------------------------------------------------

        [시작 버튼 클릭]
              |
              v
    +---------------------+
    |  인터록 전체 확인   |
    |  (AND 로직)         |
    +---------------------+
         |           |
    [모두 충족]  [하나라도 불충족]
         |           |
         v           v
    +---------+  +---------------------+
    | 첫 항목 |  | 시작 거부           |
    | 실행    |  | 불충족 조건 표시    |
    +---------+  +---------------------+
         |
         v
    +---------------------------------------------+
    |        사이클 실행 모니터링                 |
    |  - 인터록 지속 감시 (200ms)                 |
    |  - M30 (프로그램 종료) 대기                 |
    +---------------------------------------------+
         |           |           |
    [M30 수신]  [인터록 위반] [정지 버튼]
         |           |           |
         v           v           v
    COUNT++     Feed Hold    1사이클 후
    PRESET?     즉시 정지    정지
         |
    [도달] -> 다음 항목으로
    [미도달] -> 다음 사이클 시작


[지적 6: 정지 동작 불일치]

| 상황        | 문서 설명                | 실제 의미    |
|-------------|--------------------------|--------------|
| 정지 버튼   | "현재 사이클 완료 후 정지"| 안전한 정지  |
| 인터록 위반 | "Feed Hold 전송"         | 즉시 정지    |

Feed Hold는 이송을 즉시 멈추는 신호입니다. "1사이클 완료 후 정지"와 다릅니다.

모순: 인터록 위반은 안전 문제인데, 왜 즉시 정지하고
      정지 버튼은 1사이클 완료를 기다리는가?

명확화 필요:
- 인터록 위반 시: 즉시 Feed Hold (맞음)
- 정지 버튼: Single Block ON + 1사이클 완료 대기? 아니면 다른 방법?


[지적 7: 프로그램 존재 여부 검증 누락]

"Main PGM 선택 -> FOCAS 사이클 스타트"

질문: 스케줄러에 등록된 O0001이 CNC에 없으면?
- 오류 반환 후 다음 항목으로?
- Transfer 후 재시도?
- 스케줄러 전체 정지?

이 시나리오가 정의되어 있지 않습니다.


================================================================================
7. Transfer 기능
================================================================================

7.1 Transfer vs 스케줄러
--------------------------------------------------------------------------------

+---------------------------------------------------------------------+
|                    스케줄러                                         |
|  - 프로그램 실행 (사이클 스타트)                                    |
|  - 인터록 필수                                                      |
|  - 실시간 모니터링 연동                                             |
+---------------------------------------------------------------------+

+---------------------------------------------------------------------+
|                    Transfer                                         |
|  - 프로그램 입출력 (파일 전송)                                      |
|  - 인터록 무관 (단, 장비 정지 권장)                                 |
|  - 스케줄러와 동시 사용 불가                                        |
+---------------------------------------------------------------------+


7.2 Transfer 기능 구성
--------------------------------------------------------------------------------
1. INPUT  (Server -> CNC)
   - 네트워크 폴더의 프로그램을 CNC로 전송
   - FOCAS: cnc_dwnstart3 -> cnc_download3 -> cnc_dwnend3

2. OUTPUT (CNC -> Server)
   - CNC의 프로그램을 네트워크 폴더로 저장
   - FOCAS: cnc_upstart3 -> cnc_upload3 -> cnc_upend3

3. 전체 백업
   - SRAM, 파라미터, 프로그램, OFFSET
   - 결과: backup_YYYYMMDD_HHMMSS.zip


[지적 8: 복원(Restore) 프로세스 누락]

백업은 상세하게 정의되어 있으나, 복원 절차가 전혀 없습니다.

필요한 정의:
- 복원 UI/API
- 부분 복원 가능 여부 (프로그램만, 파라미터만)
- 복원 시 기존 데이터 덮어쓰기 확인
- 복원 중 오류 시 롤백


[지적 9: 상호 배제 구현 방법 미정의]

"스케줄러와 동시 동작 불가"

구현 방법이 없음:
- UI에서 비활성화?
- Server에서 거부?
- 락 메커니즘?
- 스케줄러 실행 중 Transfer 시도 시 응답?


================================================================================
8. POP / MES 연계
================================================================================

8.1 POP (생산실적 집계)
--------------------------------------------------------------------------------
interface ProductionMetrics {
  runTime: number;           // 가동 시간
  idleTime: number;          // 대기 시간
  alarmTime: number;         // 알람 시간

  totalParts: number;        // 총 생산량
  goodParts: number;         // 양품
  defectParts: number;       // 불량

  utilization: number;       // 가동률
  oee: number;               // 설비종합효율
}


8.2 이력 관리
--------------------------------------------------------------------------------
프로그램 실행 이력
+-- machineId, programNumber
+-- startTime, endTime
+-- partsProduced
+-- status (completed/interrupted/error)

알람 이력
+-- alarmNumber, alarmMessage
+-- occurredAt, clearedAt
+-- duration
+-- category (system/program/servo/pmc)


8.3 MES 연계 (작업지시)
--------------------------------------------------------------------------------
interface WorkOrder {
  orderNumber: string;       // 작업지시 번호
  productCode: string;       // 제품 코드
  targetQuantity: number;    // 목표 수량
  assignedMachine: string;   // 배정 장비
  programNumber: string;     // 사용 프로그램
  status: 'pending' | 'in_progress' | 'completed' | 'cancelled';
}


[지적 10: POP 데이터 소스 미정의]

utilizationFormula: "(runTime / totalTime) * 100"

질문:
- runTime은 어디서 오는가? Agent가 계산? Server가 집계?
- 집계 기준 시간(시프트 시작/종료)은?
- Agent 오프라인 기간의 데이터는?


[지적 11: MES 연계 방향성 모호]

WorkOrder 인터페이스는 있는데:
- 외부 MES에서 가져오는 건가?
- 이 시스템에서 생성하는 건가?
- 연계 방식(REST API, 파일, DB)은?
- 양방향 동기화 시 충돌 해결은?


================================================================================
9. 안전성 및 확장성
================================================================================

9.1 인터록 시스템
--------------------------------------------------------------------------------
// 인터록 검증 결과 예시
{
  "allPassed": false,
  "checks": [
    { "condition": "doorClosed",     "passed": true  },
    { "condition": "chuckClamped",   "passed": true  },
    { "condition": "spindleStopped", "passed": false },  // 실패
    { "condition": "barFeederReady", "passed": true  }
  ],
  "blockedBy": ["spindleStopped"]
}

모든 조건이 AND로 충족되어야 동작 허용.


9.2 명령 검증 체인
--------------------------------------------------------------------------------
사용자 요청
    |
    v
1. 인증 확인     -> 실패: 401 Unauthorized
    |
    v
2. 권한 확인     -> 실패: 403 Forbidden
    |
    v
3. 명령 유효성   -> 실패: 400 Bad Request
    |
    v
4. 인터록 확인   -> 실패: 409 Conflict + 상세 사유
    |
    v
5. 명령 실행


9.3 확장성
--------------------------------------------------------------------------------
현재: 10대                      확장: 20대
+----+ +----+    +----+        +----+ +----+    +-----+
|Ag 1| |Ag 2| .. |Ag10|        |Ag 1| |Ag 2| .. |Ag 20|
+----+ +----+    +----+        +----+ +----+    +-----+
   |      |         |             |      |          |
   +------+---------+             +------+----------+
           |                               |
    Central Server                  Central Server (동일)

Agent만 추가하면 확장 가능 (Server 변경 불필요)


[지적 12: Agent 독립 동작의 모순]

문서 9.2.3: "서버 다운 -> Agent 독립 동작 (로컬 캐싱)"
문서 4.3: "Agent 시작 시 Server에서 템플릿 정보 수신"

모순: Server 없이 Agent가 어떻게 동작하나?

필요한 정의:
- 로컬 캐싱 대상 (템플릿, 설정, 명령 큐)
- 캐시 저장 방식 (SQLite, 파일)
- 오프라인 시 가능한 동작 범위
- 복구 시 동기화 절차


================================================================================
10. 구현 시 주요 위험 요소 정리
================================================================================

| # | 위험 요소                          | 심각도 | 권장 조치                        |
|---|------------------------------------|--------|----------------------------------|
| 1 | 인터록 비활성화로 인한 안전 사고   | 높음   | 필수 인터록 분리, 승인 절차      |
| 2 | MQTT 직접 접근으로 Server 우회     | 높음   | MQTT Broker ACL, Agent 인증      |
| 3 | Server 다운 시 Agent 동작 불가     | 중간   | 템플릿/설정 로컬 캐싱 구현       |
| 4 | 스케줄러-Transfer 동시 실행        | 중간   | 상호 배제 락 메커니즘 정의       |
| 5 | 프로그램 미존재 시 스케줄러 동작   | 중간   | 실행 전 프로그램 존재 검증       |
| 6 | 카운터 동기화 불일치               | 중간   | CNC-스케줄러 COUNT 동기화 정책   |
| 7 | 백업 후 복원 불가                  | 낮음   | Restore 프로세스 정의            |
| 8 | 메시지 스키마 미정의               | 낮음   | MQTT/WebSocket 포맷 표준화       |


================================================================================
11. 개발 전 확정 필요 사항
================================================================================

| 항목        | 선택지                | 권장                              |
|-------------|-----------------------|-----------------------------------|
| 인증 방식   | JWT vs Session        | JWT (Stateless, 확장성)           |
| 데이터베이스| PostgreSQL vs MySQL   | PostgreSQL + TimescaleDB (시계열) |
| Agent 캐싱  | SQLite vs 파일        | SQLite (트랜잭션 지원)            |
| MQTT 보안   | TLS + ACL             | 필수                              |


================================================================================
                           지적 사항 요약 (총 12건)
================================================================================

[지적 1]  권한 경계 모호 - 관리자/AS 담당자 권한 중복
[지적 2]  책임 경계 충돌 - MQTT 직접 접근 시 Server 우회 가능
[지적 3]  인터록 비활성화 안전 문제 - 필수/선택 분리 필요
[지적 4]  템플릿 로드 시점 문제 - Server 다운 시 Agent 시작 불가
[지적 5]  명령 응답 흐름 누락 - Agent->Server->Frontend 응답 경로 미정의
[지적 6]  정지 동작 불일치 - Feed Hold vs 1사이클 완료 후 정지
[지적 7]  프로그램 존재 여부 검증 누락 - CNC에 프로그램 없을 때 동작
[지적 8]  복원(Restore) 프로세스 누락 - 백업만 있고 복원 없음
[지적 9]  상호 배제 구현 방법 미정의 - 스케줄러/Transfer 동시 방지
[지적 10] POP 데이터 소스 미정의 - runTime 등 출처 불명
[지적 11] MES 연계 방향성 모호 - 데이터 흐름 방향 미정의
[지적 12] Agent 독립 동작의 모순 - 로컬 캐싱 vs Server 의존


================================================================================
                              검토일: 2026-01-22
================================================================================
